# Continuous Integration for deferred-apps
#
# Runs on every push and pull request to ensure code quality:
# - Nix flake checks (module evaluation, library tests)
# - Code formatting (nixfmt-rfc-style)
# - Static analysis (statix lints, deadnix unused code detection)
# - Flake health checks (nixpkgs freshness, supported refs)

name: CI

on:
  push:
    branches: [main]
  pull_request:
  # Allow manual triggering
  workflow_dispatch:

# Cancel in-progress runs for the same branch
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  # ===========================================================================
  # Detect which files changed to skip unnecessary jobs
  # ===========================================================================
  changes:
    name: Detect changes
    runs-on: ubuntu-latest
    permissions:
      pull-requests: read
    outputs:
      nix: ${{ steps.filter.outputs.nix }}
      docs: ${{ steps.filter.outputs.docs }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            nix:
              - '**/*.nix'
              - 'flake.lock'
            docs:
              - '**/*.md'
              - 'LICENSE'

  # ===========================================================================
  # Core Nix checks - runs flake check which includes module evaluation
  # ===========================================================================
  flake-check:
    name: Flake check
    needs: changes
    if: ${{ needs.changes.outputs.nix == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            accept-flake-config = true
            experimental-features = nix-command flakes

      - name: Check flake.lock health
        uses: DeterminateSystems/flake-checker-action@v9
        with:
          fail-mode: true

      - name: Run flake checks
        run: nix flake check --print-build-logs

  # ===========================================================================
  # Code formatting - ensures consistent style
  # ===========================================================================
  formatting:
    name: Check formatting
    needs: changes
    if: ${{ needs.changes.outputs.nix == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            experimental-features = nix-command flakes

      - name: Check Nix formatting
        run: |
          echo "Checking Nix file formatting with nixfmt-rfc-style..."
          # Find all .nix files and check formatting
          find . -name '*.nix' -type f | xargs nix develop .#ci --command nixfmt --check

  # ===========================================================================
  # Static analysis - linting and dead code detection
  # ===========================================================================
  lint:
    name: Lint
    needs: changes
    if: ${{ needs.changes.outputs.nix == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            experimental-features = nix-command flakes

      - name: Run statix (Nix linter)
        run: |
          echo "Running statix for Nix lints and suggestions..."
          nix develop .#ci --command statix check .

      - name: Run deadnix (unused code detector)
        run: |
          echo "Checking for unused Nix code with deadnix..."
          # -L: Don't check lambda attrset pattern names (nixpkgs callPackage compatibility)
          nix develop .#ci --command deadnix --fail -L .

  # ===========================================================================
  # Test suite - comprehensive tests for library, module, and edge cases
  # ===========================================================================
  test-suite:
    name: Test suite
    needs: changes
    if: ${{ needs.changes.outputs.nix == 'true' || github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Install Nix
        uses: cachix/install-nix-action@v31
        with:
          extra_nix_config: |
            experimental-features = nix-command flakes

      - name: List all test cases
        run: |
          echo "Available test cases in tests.nix:"
          nix eval .#checks.x86_64-linux --apply 'checks: builtins.attrNames checks' --json | jq -r '.[]' | sort

      - name: Run library tests
        run: |
          echo "Running library function tests..."
          for check in $(nix eval .#checks.x86_64-linux --apply 'checks: builtins.attrNames checks' --json | jq -r '.[]' | grep '^lib-'); do
            echo "  Building: $check"
            nix build ".#checks.x86_64-linux.$check" --print-build-logs
          done
          echo "✓ All library tests passed"

      - name: Run collision detection tests
        run: |
          echo "Running collision detection tests..."
          for check in $(nix eval .#checks.x86_64-linux --apply 'checks: builtins.attrNames checks' --json | jq -r '.[]' | grep '^collision-'); do
            echo "  Building: $check"
            nix build ".#checks.x86_64-linux.$check" --print-build-logs
          done
          echo "✓ All collision detection tests passed"

      - name: Run module tests
        run: |
          echo "Running NixOS module tests..."
          for check in $(nix eval .#checks.x86_64-linux --apply 'checks: builtins.attrNames checks' --json | jq -r '.[]' | grep '^module-'); do
            echo "  Building: $check"
            nix build ".#checks.x86_64-linux.$check" --print-build-logs
          done
          echo "✓ All module tests passed"

      - name: Run error handling tests
        run: |
          echo "Running error handling tests..."
          for check in $(nix eval .#checks.x86_64-linux --apply 'checks: builtins.attrNames checks' --json | jq -r '.[]' | grep '^error-'); do
            echo "  Building: $check"
            nix build ".#checks.x86_64-linux.$check" --print-build-logs
          done
          echo "✓ All error handling tests passed"

      - name: Verify build outputs structure
        run: |
          echo "Verifying build output structure..."
          result=$(nix build .#checks.x86_64-linux.lib-mkDeferredApp --print-out-paths)
          
          # Check that wrapper script exists (in libexec, not bin)
          if [[ ! -f "$result/libexec/deferred-hello" ]]; then
            echo "ERROR: deferred-hello wrapper not found in libexec"
            exit 1
          fi
          
          # Check that desktop file exists
          if [[ ! -f "$result/share/applications/hello.desktop" ]]; then
            echo "ERROR: hello.desktop not found"
            exit 1
          fi
          
          # Check that terminal symlink exists in bin
          if [[ ! -L "$result/bin/hello" ]]; then
            echo "ERROR: hello symlink not found"
            exit 1
          fi
          
          echo "✓ All build outputs verified successfully!"

  # ===========================================================================
  # Summary job - provides clear status
  # ===========================================================================
  ci-success:
    name: CI Success
    needs: [flake-check, formatting, lint, test-suite]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: Check all jobs passed
        run: |
          if [[ "${{ needs.flake-check.result }}" == "failure" ]] || \
             [[ "${{ needs.formatting.result }}" == "failure" ]] || \
             [[ "${{ needs.lint.result }}" == "failure" ]] || \
             [[ "${{ needs.test-suite.result }}" == "failure" ]]; then
            echo "One or more CI jobs failed"
            exit 1
          fi
          echo "All CI checks passed!"
